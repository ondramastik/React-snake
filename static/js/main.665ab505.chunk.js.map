{"version":3,"sources":["domain/Direction.ts","domain/TileType.ts","service/SnakeService.ts","service/mock/MockedSnakeService.ts","context/SnakeServiceContext.tsx","components/game/game-field/GameFieldPresenter.tsx","components/game/Game.tsx","context/MapServiceContext.tsx","service/HttpMapService.ts","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["Direction","TileType","SnakeService","map","speed","_map","foodLocation","snakeTiles","score","tickNumber","error","errorCause","prevDirection","eatingAudio","Audio","deathAudio","this","startDirection","generateFoodLocation","tiles","startLocation","load","direction","Promise","resolve","reject","isValidDirection","newDirection","undefined","gameView","handleTick","e","message","play","getGameMeta","currentHeadPos","length","newPos","Top","X","Down","Left","Y","Right","validate","push","shift","nextTickIn","Error","Floor","Food","includes","filter","snakeLoc","x","tmp","randomIndex","y","max","Math","floor","random","MockedSnakeService","SnakeServiceContext","React","createContext","GameFieldPresenter","gameMap","gameMeta","id","style","position","row","Fragment","tile","className","top","left","location","Snake","Game","snakeService","useContext","useState","setGameMeta","running","setRunning","nextDirection","setNextDirection","tickInProgress","setTickInProgress","restart","useCallback","reset","then","useEffect","document","addEventListener","code","tick","meta","setTimeout","catch","getScore","hasError","getErrorCause","getMap","onClick","disabled","MapServiceContext","HttpMapService","axios","get","response","data","name","App","mapService","setSnakeService","Provider","value","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.665ab505.chunk.js","sourcesContent":["export enum Direction {\n  Top,\n  Down,\n  Left,\n  Right\n}","export enum TileType {\n  Empty,\n  Floor,\n  Wall,\n  Snake,\n  Food,\n}","import ISnakeService from \"../domain/service/SnakeService\";\nimport GameMeta from \"../domain/GameMeta\";\nimport {Direction} from \"../domain/Direction\";\nimport {TileType} from \"../domain/TileType\";\nimport Coordinates from \"../domain/Coordinates\";\nimport GameMap from \"../domain/GameMap\";\n\nexport default class SnakeService implements ISnakeService {\n\n    private _map: GameMap\n\n    private foodLocation: Coordinates\n\n    private snakeTiles: Coordinates[]\n\n    private score: number = 0\n\n    private tickNumber: number = 0\n\n    private error: boolean = false\n\n    private errorCause: string | undefined\n\n    private speed: number\n\n    private prevDirection: Direction\n\n    private eatingAudio = new Audio('/React-snake/resources/audio/eating.wav');\n    private deathAudio = new Audio('/React-snake/resources/audio/death.mp3');\n\n    constructor(map: GameMap, speed: number = 5) {\n        this._map = map\n        this.prevDirection = map.startDirection\n        this.foodLocation = SnakeService.generateFoodLocation(map.tiles)\n        this.snakeTiles = [{...map.startLocation}]\n        this.speed = speed\n        this.eatingAudio.load()\n        this.deathAudio.load()\n    }\n\n    getMap(): GameMap {\n        return this._map;\n    }\n\n    tick(direction?: Direction): Promise<GameMeta> {\n        return new Promise<GameMeta>((resolve, reject) => {\n            try {\n                const isValidDirection = SnakeService.isValidDirection(this.prevDirection, direction)\n                const newDirection = direction !== undefined && isValidDirection ? direction : this.prevDirection\n                const gameView = this.handleTick(newDirection)\n                this.prevDirection = newDirection\n                resolve(gameView)\n            } catch (e) {\n                this.error = true\n                this.errorCause = (e as Error).message\n                this.deathAudio.play()\n                reject(e)\n            }\n        })\n    }\n\n    reset(): Promise<GameMeta> {\n        this.snakeTiles = [{...this._map.startLocation}]\n        this.foodLocation = SnakeService.generateFoodLocation(this._map.tiles)\n        this.score = 0\n        this.tickNumber = 0\n        this.error = false\n        this.errorCause = undefined\n\n        return Promise.resolve(this.getGameMeta())\n    }\n\n    getErrorCause(): string | undefined {\n        return this.errorCause;\n    }\n\n    getScore(): number {\n        return this.score;\n    }\n\n    getTickNumber(): number {\n        return this.tickNumber;\n    }\n\n    hasError(): boolean {\n        return this.error;\n    }\n\n\n    private handleTick(direction: Direction): GameMeta {\n        const currentHeadPos = this.snakeTiles[this.snakeTiles.length - 1]\n        const newPos = {...currentHeadPos}\n\n        switch (direction) {\n            case Direction.Top:\n                newPos.X -= 1\n                break;\n            case Direction.Down:\n                newPos.X += 1\n                break;\n            case Direction.Left:\n                newPos.Y -= 1\n                break;\n            case Direction.Right:\n                newPos.Y += 1\n                break;\n        }\n\n        this.validate(newPos)\n\n        this.snakeTiles.push(newPos)\n\n        if (this.foodLocation.X === newPos.X && this.foodLocation.Y === newPos.Y) {\n            this.eatingAudio.play()\n            this.foodLocation = SnakeService.generateFoodLocation(this._map.tiles)\n            this.score += this.speed\n        } else this.snakeTiles.shift()\n\n\n        return this.getGameMeta()\n    }\n\n    private getGameMeta(): GameMeta {\n        return {\n            snakeTiles: this.snakeTiles,\n            foodLocation: this.foodLocation,\n            nextTickIn: (11 - this.speed) * 25\n        }\n    }\n\n    private validate(newPos: Coordinates): void {\n        if (!this._map.tiles[newPos.X][newPos.Y]) {\n            throw Error(\"Player out of field\")\n        }\n        if (![TileType.Floor, TileType.Food].includes(this._map.tiles[newPos.X][newPos.Y])) {\n            throw Error(\"Player crashed\")\n        }\n        if (this.snakeTiles.filter(snakeLoc => snakeLoc.X === newPos.X && snakeLoc.Y === newPos.Y).length > 0) {\n            throw Error(\"The player ate himself\")\n        }\n    }\n\n    private static generateFoodLocation(tiles: TileType[][]): Coordinates {\n        let x: number = -1\n\n        while (true) {\n            let tmp = SnakeService.randomIndex(tiles.length)\n            if (tiles[tmp] !== undefined && tiles[tmp].includes(TileType.Floor)) {\n                x = tmp\n                break;\n            }\n        }\n\n        let y: number = -1\n\n        while (true) {\n            let tmp = SnakeService.randomIndex(tiles[x].length)\n            if (tiles[x][tmp] !== undefined && tiles[x][tmp] === TileType.Floor) {\n                y = tmp\n                break;\n            }\n        }\n\n        return {\n            X: x,\n            Y: y\n        }\n    }\n\n    private static randomIndex(max: number): number {\n        return Math.floor((Math.random() * max))\n    }\n\n    private static isValidDirection(prevDirection?: Direction, newDirection?: Direction): boolean {\n        switch (newDirection) {\n            case Direction.Left:\n                if (prevDirection === Direction.Right)\n                    return false\n                break\n            case Direction.Top:\n                if (prevDirection === Direction.Down)\n                    return false\n                break\n            case Direction.Right:\n                if (prevDirection === Direction.Left)\n                    return false\n                break\n            case Direction.Down:\n                if (prevDirection === Direction.Top)\n                    return false\n                break\n        }\n        return true\n    }\n\n\n}","import ISnakeService from \"../../domain/service/SnakeService\";\nimport GameMeta from \"../../domain/GameMeta\";\nimport {Direction} from \"../../domain/Direction\";\nimport GameMap from \"../../domain/GameMap\";\n\n\nexport default class MockedSnakeService implements ISnakeService {\n\n    getMap(): GameMap {\n        return {} as GameMap;\n    }\n\n    tick(direction?: Direction): Promise<GameMeta> {\n        return Promise.resolve({tiles: [], snakeTiles: [], foodLocation: {X: 1, Y: 1}, nextTickIn: 50})\n    }\n\n    reset(): Promise<GameMeta> {\n        return Promise.resolve({tiles: [], snakeTiles: [], foodLocation: {X: 1, Y: 1}, nextTickIn: 50})\n    }\n\n    getErrorCause(): string | undefined {\n        return undefined;\n    }\n\n    getScore(): number {\n        return 0;\n    }\n\n    getTickNumber(): number {\n        return 0;\n    }\n\n    hasError(): boolean {\n        return false;\n    }\n\n}","import React from \"react\"\nimport ISnakeService from \"../domain/service/SnakeService\";\nimport MockedSnakeService from \"../service/mock/MockedSnakeService\";\n\nexport const SnakeServiceContext = React.createContext<ISnakeService>(new MockedSnakeService())","import React, {FC} from 'react';\nimport './GameFieldPresenter.css';\nimport GameMeta from \"../../../domain/GameMeta\";\nimport {TileType} from \"../../../domain/TileType\";\nimport GameMap from \"../../../domain/GameMap\";\n\ninterface Props {\n    gameMap: GameMap\n    gameMeta: GameMeta\n}\n\n\nconst GameFieldPresenter: FC<Props> = ({gameMap, gameMeta}) => {\n    return <div id=\"game-field-presenter\" style={{position: \"relative\"}}>\n        {gameMap.tiles.map(\n            (row, x) => <React.Fragment>\n                {row.map((tile, y) => <div\n                    className={`tile tile-${gameMap.tiles[x][y]}`} key={`${x}-${y}`}/>)}\n                <div/>\n            </React.Fragment>)}\n        <div style={{position: \"absolute\", top: 20 * gameMeta.foodLocation.X, left: 20 * gameMeta.foodLocation.Y}}\n             className={`tile tile-${TileType.Food}`}/>\n        {gameMeta.snakeTiles.map(location => <div\n            style={{position: \"absolute\", top: 20 * location.X, left: 20 * location.Y}}\n            className={`tile tile-${TileType.Snake}`}\n            key={`snake-${location.X}-${location.Y}`}/>)}\n    </div>\n}\n\nexport default GameFieldPresenter\n","import React, {FC, useCallback, useContext, useEffect, useState} from 'react';\nimport GameMeta from \"../../domain/GameMeta\";\nimport ISnakeService from \"../../domain/service/SnakeService\";\nimport {SnakeServiceContext} from \"../../context/SnakeServiceContext\";\nimport GameFieldPresenter from \"./game-field/GameFieldPresenter\";\nimport {Direction} from \"../../domain/Direction\";\n\n\nconst Game: FC = () => {\n    const snakeService: ISnakeService = useContext(SnakeServiceContext)\n\n    const [gameMeta, setGameMeta] = useState<GameMeta | undefined>()\n\n    const [running, setRunning] = useState(true)\n\n    const [nextDirection, setNextDirection] = useState<Direction>()\n    const [tickInProgress, setTickInProgress] = useState<boolean>(false)\n\n    const restart = useCallback(() => {\n        snakeService.reset()\n            .then(gameView => setGameMeta(gameView))\n\n        setRunning(true)\n        setNextDirection(undefined)\n        setTickInProgress(false)\n    }, [snakeService])\n\n    useEffect(() => {\n        document.addEventListener('keydown', function (e) {\n            let newDirection: Direction | undefined = undefined\n            switch (e.code) {\n                case \"ArrowLeft\":\n                    newDirection = Direction.Left\n                    break;\n                case \"ArrowUp\":\n                    newDirection = Direction.Top\n                    break;\n                case \"ArrowRight\":\n                    newDirection = Direction.Right\n                    break;\n                case \"ArrowDown\":\n                    newDirection = Direction.Down\n                    break;\n                case \"Space\":\n                    restart()\n                    break;\n            }\n\n            if (newDirection !== undefined) {\n                setNextDirection(newDirection)\n            }\n        })\n    }, [restart])\n\n    useEffect(() => {\n        if (running && !tickInProgress) {\n            setTickInProgress(true)\n            snakeService\n                .tick(nextDirection)\n                .then(meta => setTimeout(() => setGameMeta(meta), meta.nextTickIn))\n                .then(() => setTickInProgress(false))\n                .catch(() => {\n                    setRunning(false)\n                })\n        }\n    }, [gameMeta])\n\n\n    return <div id=\"game\">\n        <h1>Score: {snakeService.getScore()}</h1>\n        {snakeService.hasError() && <h1>Error: {snakeService.getErrorCause()}</h1>}\n        {gameMeta && <GameFieldPresenter gameMap={snakeService.getMap()} gameMeta={gameMeta}/>}\n        <button onClick={() => restart()} disabled={running}>Restart</button>\n    </div>\n}\n\nexport default Game\n","import React from \"react\"\nimport IMapService from \"../domain/service/IMapService\";\n\nexport const MapServiceContext = React.createContext<IMapService>({} as IMapService);","import IMapService from \"../domain/service/IMapService\";\nimport {TileType} from \"../domain/TileType\";\nimport axios from 'axios';\n\nexport default class HttpMapService implements IMapService {\n\n    list(): Promise<string[]> {\n        return axios.get('/React-snake/resources/maps/maplist.json').then(response => response.data)\n    }\n\n    load(name: string): Promise<TileType[][]> {\n        return axios.get(`/React-snake/resources/maps/${name}.json`).then(response => response.data)\n    }\n\n}","import React, {useEffect, useState} from 'react';\nimport SnakeService from \"../service/SnakeService\";\nimport {Direction} from \"../domain/Direction\";\nimport Game from \"./game/Game\";\nimport {SnakeServiceContext} from \"../context/SnakeServiceContext\";\nimport {MapServiceContext} from \"../context/MapServiceContext\";\nimport HttpMapService from \"../service/HttpMapService\";\nimport ISnakeService from \"../domain/service/SnakeService\";\n\nfunction App() {\n    const [mapService] = useState(new HttpMapService())\n    const [snakeService, setSnakeService] = useState<ISnakeService>()\n\n    useEffect(() => {\n        if (!snakeService) {\n            mapService.load(\"map1\")\n                .then(map => setSnakeService(new SnakeService({\n                    tiles: map,\n                    startLocation: {\n                        X: 1,\n                        Y: 1\n                    },\n                    startDirection: Direction.Down\n                })))\n        }\n    })\n\n    return (\n        <div className=\"App\">\n            {snakeService && <SnakeServiceContext.Provider value={snakeService}>\n                <MapServiceContext.Provider value={mapService}>\n                    <Game />\n                </MapServiceContext.Provider>\n            </SnakeServiceContext.Provider>}\n        </div>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}